# 빠른 CPU를 위한 설계 기법/ CPU성능 향상

- 클럭
    - CPU의 속도를 결정하는 요소
    - 클럭 속도: HZ단위(1초에 클릭이 몇 번 반복되는지) -> CPU속도 단위로 간주되기도 함/ 일정하게 유지되기 보단 필요에 의해 유연하게 높,낮 됨
    - 오버클럭킹: 최대 클럭속도 강제로 높이는 기술/ 성능 향상 but 안정성 저하

- 코어와 멀티코어
    - 코어: CPU에서 명령어를 실행하는 부품
    - 멀티코어: 여러 개의 코어를 포함하는 CPU/ 듀얼,쿼드, 옥타 : 2,4,8
    - 코어마다 처리할 명령어들을 적절하게 분배하느냐에 따라 연산속도 달라짐
    -> 무작정 코어 수 늘리지 않는 이유

- 스레드, 멀티스레드
    - 스레드: 실행 흐름 단위
        - 하드웨어적 스레드: 하나의 코어가 동시에 처리하는 명령어 단위
            - 멀티스레드 프로세서: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
                1. 하이퍼스레딩: 인텔의 멀티스레딩 기술 -> 하나의 물리적 코어를 논리적으로 두 개처럼 활용하여 동시 실행 성능을 향상 

        - 소프트웨어적 스레드: 하나의 프로그램에서 독립적으로 실행되는 단위(프로그램의 여러 부분이 동시에 실행될 수도 있음)

# 명령어 병렬 처리 기법

- 명령어 병렬 처리 기법: 명령어를 동시에 처리하여 CPU를 쉬지 않고 작동시키는 기법
    - 명령어 파이프라이닝: 여러 개의 명령어를 겹쳐서 실행하는 기법 
        - 명령어 처리과정(클럭단위로 나누어 보기)
            1. 명령어 인출(Fetch)
            2. 명령어 해석(Decode)
            3. 명령어 실행(Execute)
            4. 결과 저장(Write Back)
            - 각 단계가 겹치지만 않는다면 동시 실행 가능
        - 파이프 라인 위험(특정 상황)
            1. 데이터 위험: 명령어 간 데이터 의존성으로 인해 발생 
            2. 제어 위험: 프로그램 카운터의 갑작스러운 변화!에 의해 발생
                - 분기 예측: 프로그램이 어디로 분기할지 예측하여 미리 실행
                - 프로그램 카운터 -> 현재 실행 중인 명령어의 다음 주소로 갱신!
                but 1) 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서
                    2) 프로그램 카운터 값의 변화가 생기고 
                    3) 명령어 파이프라인에 미리 와서 처리중이었던 명령어들이 무의미
                    4) 이것이 '제어 위험'
            3. 구조적 위험: 서로 다른 명령어가 동시에 같은 자원(CPU, 레지스터 등과 같은 부품)을 사용할 때 발생
    - 슈퍼 스칼라: 여러개의 파이프라인을 활용하여 동시에 여러 명령어를 실행하는 기법/ 단순 파이프라이닝보다 더 많은 명령어를 동시에 실행 가능

    - 비순차적 명령어 처리: 명령어를 순차적으로 실행하지 않고, 실행가능한 명령어를 먼저 실행/ CPU가 효율적으로 자원을 사용하고 성능을 높이는 데 기여

# CISC와 RISC

- 명령어 집합 구조(ISA)
    - CISC: 가변 길이 명령어를 사용하는 복잡하고 다양한 명령어를 제공하는 CPU 아키텍처
        - 장점: 강력한 명령어 지원 -> 소프트웨어 개발이 쉬움
        - 단점: 하드웨어 설계가 복잡하고 전력 소비가 많음
    - RISC: 고정 길이 명령어 사용/ 단순한 명령어를 사용하여 속도를 높이는 CPU 아키텍처
        - 장점: 실행 속도 빠르고 저전력
        - 단점: 복잡한 연산을 수행하려면 더 많은 명령어가 필요함 


    